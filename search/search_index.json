{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Snitch System Generator The Snitch project is an open-source RISC-V hardware research project of ETH Zurich and University of Bologna targeting highest possible energy-efficiency. The system is designed around a versatile and small integer core, which we call Snitch. The system is ought to be highly parameterizable and suitable for many use-cases, ranging from small, control-only cores, to large many-core system made for pure number crunching in the HPC domain. Getting Started TODO(zarubaf) TBD once the system stabilizes. Documentation The documentation is built from the latest master and hosted at github pages: https://pulp-platform.github.io/snitch . About this Repository This repository is developed as a monorepo, external dependencies are \"vendored-in\" and checked in. Keeping it a monolithic repository helps to keep the hardware dependencies under control and enables precise snapshotting (invaluable when you are taping-out chips). Licensing TODO(zarubaf): TBD once licensing is determined.","title":"Home"},{"location":"#snitch-system-generator","text":"The Snitch project is an open-source RISC-V hardware research project of ETH Zurich and University of Bologna targeting highest possible energy-efficiency. The system is designed around a versatile and small integer core, which we call Snitch. The system is ought to be highly parameterizable and suitable for many use-cases, ranging from small, control-only cores, to large many-core system made for pure number crunching in the HPC domain.","title":"Snitch System Generator"},{"location":"#getting-started","text":"TODO(zarubaf) TBD once the system stabilizes.","title":"Getting Started"},{"location":"#documentation","text":"The documentation is built from the latest master and hosted at github pages: https://pulp-platform.github.io/snitch .","title":"Documentation"},{"location":"#about-this-repository","text":"This repository is developed as a monorepo, external dependencies are \"vendored-in\" and checked in. Keeping it a monolithic repository helps to keep the hardware dependencies under control and enables precise snapshotting (invaluable when you are taping-out chips).","title":"About this Repository"},{"location":"#licensing","text":"TODO(zarubaf): TBD once licensing is determined.","title":"Licensing"},{"location":"rm/solder/","text":"Solder Solder generates (complex) interconnects, their respective address maps, and SystemVerilog description from a simple, imperative Python description. The user specifies the topology and high-level address map of the system using Solder's API. Solder will take of generating the underlying graph representations, propagating address maps, calculating routes and performing various sanity checks. Finally, the hardware description is generated. Graph Representations Under the hood Solder maintains several different graph representations: Hardware instance graph This representation contains all hardware blocks which need to be instantiated. This includes crossbars, converter modules and peripherals. Address Map Graph Provides an abstract view of the memory map. Components which do not change the topology (router nodes) or routing decisions (filters and leafs) are stripped from the representation.","title":"Solder"},{"location":"rm/solder/#solder","text":"Solder generates (complex) interconnects, their respective address maps, and SystemVerilog description from a simple, imperative Python description. The user specifies the topology and high-level address map of the system using Solder's API. Solder will take of generating the underlying graph representations, propagating address maps, calculating routes and performing various sanity checks. Finally, the hardware description is generated.","title":"Solder"},{"location":"rm/solder/#graph-representations","text":"Under the hood Solder maintains several different graph representations: Hardware instance graph This representation contains all hardware blocks which need to be instantiated. This includes crossbars, converter modules and peripherals. Address Map Graph Provides an abstract view of the memory map. Components which do not change the topology (router nodes) or routing decisions (filters and leafs) are stripped from the representation.","title":"Graph Representations"},{"location":"ug/directory_structure/","text":"Directory Structure The project is organized as a monolithic repository. Both hardware and software are co-located. The top-level ist structured as follows: docs : Documentation of the generator and software. Contains additional user guides. hw : All hardware components. sw : Hardware independent software, libraries, runtimes etc. util : Utility and helper scripts. Hardware ip : Blocks which are instantiated in the design e.g., they are not stand-alone. src : RTL sources test : Test-benches vendor : \"Third-party\" components which are updated using the vendor script. They are not (primarily) developed as part of this repository.","title":"Directory Structure"},{"location":"ug/directory_structure/#directory-structure","text":"The project is organized as a monolithic repository. Both hardware and software are co-located. The top-level ist structured as follows: docs : Documentation of the generator and software. Contains additional user guides. hw : All hardware components. sw : Hardware independent software, libraries, runtimes etc. util : Utility and helper scripts.","title":"Directory Structure"},{"location":"ug/directory_structure/#hardware","text":"ip : Blocks which are instantiated in the design e.g., they are not stand-alone. src : RTL sources test : Test-benches vendor : \"Third-party\" components which are updated using the vendor script. They are not (primarily) developed as part of this repository.","title":"Hardware"},{"location":"ug/documentation/","text":"Documentation Documentation of the generator and related infrastructure is hosted under docs . Static html documentation is build from the latest master branch by the CI. We use mkdocs together with the material theme . Before building the documentation, make sure you have the required dependencies installed: pip install -r docs/requirements.txt After everything ist installed, you can build and serve a local copy by executing: mkdocs serve This opens a local webserver listening on http://127.0.0.1:8000/ . Organization The docs folder is organized as follows: rm : Reference manuals, listings and detailed design decisions. ug : User guides, more tutorial style texts to get contributors and user up-to-speed.","title":"Documentation"},{"location":"ug/documentation/#documentation","text":"Documentation of the generator and related infrastructure is hosted under docs . Static html documentation is build from the latest master branch by the CI. We use mkdocs together with the material theme . Before building the documentation, make sure you have the required dependencies installed: pip install -r docs/requirements.txt After everything ist installed, you can build and serve a local copy by executing: mkdocs serve This opens a local webserver listening on http://127.0.0.1:8000/ .","title":"Documentation"},{"location":"ug/documentation/#organization","text":"The docs folder is organized as follows: rm : Reference manuals, listings and detailed design decisions. ug : User guides, more tutorial style texts to get contributors and user up-to-speed.","title":"Organization"}]}